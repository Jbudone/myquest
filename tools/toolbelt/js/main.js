//
// TODO
//  - Resource Manager
//      - Read resources and find all resources
//      - Write changes
//      - Interact w/ bash scripts & external tools
//      - Watch for changes in file
//  - Interaction module
//      - Hovering over region in preview window; project to world coordinates (zoomed in, scrolled)
//  - Preview/Renderer
//      - Render images (zoomed in, scrolling)
//      - Highlighting, grid
//  - Window manager
//      - Create different windows
//      - Automatically allow resizing/moving/etc. for certain windows
//
//  - Modules
//      - Spritesheet Editor
//      - Tilesheet Editor
//          - Show settings/data
//              - Name, image
//              - Tilesize? w/h  (how does this work in game?)
//              - List: Objects, Extractions
//              - Buttons: Collision, shoot through, floating, extract, object
//                  - Object: on click tile add a new object, on hover tile highlight object
//                  - Extract: on click button add new or select first extraction group
//              - Meta data: comments/etc.
//              - Change settings colours when there's unsaved changes (diff changes from last saved changes, so if we
//              undo our last change it doesn't show as needing to save)
//
//          - Add/Remove collision/shoot-through/floating/extract
//          - Save changes
//          - Extract sprites
//              - Autogenerated type is listed in sheets.json; has a list of dependencies, no source image, and an
//              output image
//              - Resourcebuilder:
//                  1) If an item changes which has extractions, add extraction to to-generate list (w/ the dependency included)
//                      - Prepare resource: go through all assets to build dependency list for autogenerated shit;
//                          keep track of diff of old generated assets vs. current generated json?
//                      - Processing asset: if autogenerated, compare diff (or crc) of json to see if anything has
//                          changed; if so then re-generate asset from scratch. Need to do these last! Should build a
//                          dependency graph, and have something solve it to order assets accordingly
//                      
//                      a) packageRoutines[sheets].prepare: Go through assets, if any has extractions then create/add to
//                          extraction list. If generated asset is found, then swap around so that accumulated data in
//                          the extraction is placed in a "current" object. Afterwards, check generated list to see if
//                          anything is dirty?
//
//                      b) packageRoutines[sheets].read: Add generated assets last to the list
//
//                      c) Processing asset: if generated: check if dirty. If so, build from scratch. Delete transient
//                          shit (properties added to autogenerated to help w/ determining dependencies)
//
//                      
//                  2) After building; go through to-generate list and build those next
//                  3) If to-generate item doesn't exist, create it
//
//
//                  4) Build image from generate list. NOTE: Either need to use processed image of dependency, OR need
//                      to have a preprocess on dependency asset before using the image (important for scaling/filter
//                      passing assets to fit correctly in the same generated image)
//                          - NOTE: Because of promises, we could have a queued process for our dependency image by the
//                          time we start on our generated sheet. So we either need to build a dependency graph to
//                          finish dependent assets first, OR make assets completely independent and process images
//                          which will be extracted.
//                               - Independent assets: would be nice for less complexity, slowness isn't a big deal
//                               since this only changes on full rebuild or dependency extraction changes. Also we may
//                               need different postprocessing (eg. scaling), and can easily copy postprocessing from
//                               dependency asset for temporary postprocessing before copy
//
//                               a) Gather list of dependencies
//                               b) For each dependency: for each sprite: copy sprite - do post processing - paste into
//                                  temporary image. Write image into output
//                               c) Fix: new generated asset data: Columns/tilesize/rows/sheet_offset; data, gid? output
//                               d) Save changes
//                          
//
//                  5) Compare autogenerated item (before/after) and store a translation from old sprite -> new sprite
//                  6) Go through map sources and translate necessary sprites
//                  7) Copy over sprite data for extractions (collisions, objects, etc.)   -- OR   would it be better to
//                      allow editing on the generated sheet, and simply update collisions/objects/etc. after
//                      updating image?
//                  8) If auto-generated asset now has an empty list, remove the output image, throw error if maps
//                      depend on image, and remove from sheets
//                  9) How to handle updating postprocessing for dependency?  (eg. postprocessing to brighten image)
//                      Probably best to have post-processing per-extraction group for dependency. Just copies sheet's
//                      postprocessing initially, and can be edited
//                  10) Easily/Automatically handle scaling? We know the tilesize for each dependency, just scale to the
//                      lowest or highest or something
//
//
//                  11) Allow selecting/moving groups of sprites on generated tilesheet in editor; save these positions
//                      so that when we update the sheet again, we retain the same positions for sprites, and simply
//                      toss new sprites underneath everything (ready for manual intervention/moving). Need to go
//                      through each extraction group, find all sprites that are touching each other, and group those
//                      together. Store groups of sprites. Saving changes should store sprite translations and update
//                      maps & packages/etc.
//
//                      a) Go through sprites and find those that are touching each other; separate these into groups
//                      b) Keep track of groups of sprites (merge new groups w/ old groups on save)
//                      c) Generated tilesheets: extra button for moving sprites
//                      d) Moving sprites: Hovering sprite group show edges, highlight sprites; move sprites
//                      e) Moved sprites: keep track of translation of sprites (old sprites -> new sprites)
//                      f) On save: translate necessary things from old sprite pos -> new sprites
//                          Data: collisions, objects, floating, etc.
//                          Update maps
//                          Update other things???  (eg. icons, items, etc.) -- may be better to disallow this for now,
//                          outside of maps/objects
//              
//          - Add new tilesheet:  Add New,  show blank canvas, drag/drop to add tilesheet
//          - Sheets gid
//      - Data editor (buffs, npcs, etc.)
//      - Map editor
//      - Resource viewer
//          - Searching, filtering
//          - Save changes to opened resource

const Modules = {};

let currentModule = null;

$(document).ready(() => {

    ResourceMgr.initialize().then(() => {
        ResourceMgr.buildElements();
    });

    let workingWindowEl = $('#workingWindow');
    Modules.tilesheet = new ModTilesheet( $('#ModTilesheet') );

    ResourceMgr.onSelectResource = (resDetails) => {

        const resType = resDetails.resType,
            res = resDetails.data;

        let module = null;
        if (resType === 'tilesheet') {
            module = Modules[resType];
        }

        // Need to unload the currently loading module?
        if (currentModule) {
            currentModule.unload();
        }

        if (currentModule !== module) {
            if (currentModule) {
                currentModule.uninitialize();
            }

            module.initialize();
        }

        currentModule = module;
        module.load(res);

        module.onSave = () => {
            ResourceMgr.saveResource(resDetails.resParent);
        };
    };

    let step = (delta) => {

        if (currentModule) {
            if (currentModule.step) currentModule.step(delta);
        }

        window.requestAnimationFrame(step);
    };

    step(1);
});
