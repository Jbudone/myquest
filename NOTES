
Sprites
---------
http://opengameart.org/users/emerald
http://opengameart.org/content/16x18-magic-cast-animations-sheet-1-template
http://opengameart.org/content/98-pixel-art-rpg-icons
http://opengameart.org/content/lots-of-hyptosis-tiles-organized
http://opengameart.org/content/lots-of-free-2d-tiles-and-sprites-by-hyptosis
http://www.deviantart.com/morelikethis/artists/333013048?view_mode=2
http://gaurav.munjal.us/Universal-LPC-Spritesheet-Character-Generator/
http://www.realm667.com/index.php/en/beastiary-mainmenu-136-69621/heretic-hexen-style-mainmenu-137-49102#preview-3
http://www.spriters-resource.com/pc_computer/heretic/
http://www.spriters-resource.com/pc_computer/heroes3/

Purchaseable Sprites
------------------
Trees: https://www.assetstore.unity3d.com/en/#!/content/60844

NO inventory, use a belt/pack for storing immediate items (scrolls/potions) limited space. Use Messagebox for purchasing items from shops (link texts). Store quest items internally, show a box of what items you have already (unable to drop/interact/sell those items). Pickup armour from ground to put it on; deletes your current armour in favour of this one. Allow for armour/weapon buffs (timed/perma for item): particle system which you can walk into to get effects, quest givers provide this, certain monsters, etc.

HTML elements overlay for UI

Store all json data in localstorage; compare update time of data to check for necessary redownload/setup

NOTE: its MUCH more efficient to redraw individual tiles rather than all tiles; at 75%-90% tiles being redrawn the two methods are equal, 95% tiles redrawn takes slightly longer. Worth it to only redraw where necessary

Epic quests to gain really special things: any spells (eg. heal, buffing, etc.), artifacts; Spells require mana which does not regenerate, and can only be refilled from certain (rare) fountains, hence spellcasting should be a rare and important case

Certain skill trainers around the world can raise your skills -- costs skill points which you gain 1 every 3-5 levels? Each trainer requires you to do an epic quest (story-mode type) to gain that skill :: instruments, necromancy, wands, pet charming, cooking/brewing, planting, fighting(strength, protection, dexterity, agility)?, 

Need basic items depending on where you go; those items are stored in your belt. You get those items by killing certain monsters (eg. silk from spiders nest, leather from bulls, etc.). When you die you lose ALL items and ALL gold on you. You may store gold in the bank, and also items in bank; but banks cost money weekly, and each withdrawal may cost money. On death you end up at nearest safe zone (town) which you have previously visited, and also have death sickness, and your god is mad at you

Skills: evocation (items), wand usage, instruments, pet charming, necromancy, planting (medicines, poisons creation/applying), firemaking for cooking, brewing beers & potions, martial arts (feign death, dash, sneak, stun, martial arts attacks), inscriptions (inscribing stuff in dungeons -- dungeon-wide/area buff/debuff?)

* The Stew Pot: a massive stew pot in one of the towns where you dump a bunch of random (edible) items to create a stew; the stew will have certain bonus/negative effects depending on the items and how the items react to each other

Steal ships -- get your own ship and go around the ocean; find tradeships (trading goods between cities) and overtake them. Will have to attack the guards on ththose tradeships, but taking their goods will effect the economy and trade in cities?

Possible to rob banks. Note the massive maze, traps, countless guards, dragons? etc.

A roguelike area where once you enter, you cannot get out through the same entrance. You must travel a long way to reach the end, with LOTS of heavy duty monsters and free player killing, etc. ALL of your items are dropped when you die, and free for other players to take. Perhaps a limited resurrection time with major penalties (eg. group raids). Also lots of treasure will be stored in this area for successful heroes. It is LONG which means people who enter will spend a long time in this place (hence, stores and such...perhaps enemy stores like in goblin towns or something, you will have to gain goblin faction or put on a mask to pretend to be a goblin)

Meat goes bad (necessary for disallowing auctioning/storing food with good benefits); however ice boxes exist and can serve for storing meat (raw and cooked). Ice boxes are really really heavy, so usually you have to go back to find the same ice box (maybe a really snowy mountain which is hugely dangerous where you might freeze..and things snow over..but if you remember where an ice box is, you can walk to the same spot and dig away the snow). Anybody can go into an ice box, unless you stick a lock on it

Gambling: two npc's go to an arena to fight. Players can place bets to whom will win; maybe they can help by passing the NPC some items or potions or buffs?

In-game card game like from M&M

Store maps as BSP tree? then only have to pass events from server to clients which are in sight of a given BSP node. Could extend this into fog of war for client

Store NPC history in local db, if we run into that same NPC or area again, recognize that locally and add some dialog fun, "You again?! You're ready to die again?"

RvR style areas for different factions (you can work your way into factions); taking over keeps/etc. gives a global stat gain/buff to everyone in that faction

Consider some items (core components) drop on a per-player basis? This prevents players farming areas for cash, and forces players to craft or work for their gear/utilities

Quests
 - Romeo & Juliet
 - Bridge Troll
 - Princess & Frog: go to a dangerous place and collect the right frog which the princess can kiss and turn to a prince



WORKING ON (was previously working on)
	- Error handling
	  	- Never return errors (please keep note where it may seem useful); ALWAYS test and throw as much as possible
		- throw Err(`Bad coordinates (${x}, ${y})`, requestPos, curPos)  // Always throw Err (not new) with a templated string describing as much as possible, with as many args as possible (NOTE: can't pass arguments because of strict mode)
	- Walking out of sync (testing with bot)
	- Performance on walking/AI/players/scripts (profiler; check movable.js delta's; allocate X time per timestep to AI, may need to have a queue of AI updates and round-robin update -- on AI callback, commit update/details and round-robin update)
	- client/game.js checkNewPages
	- offload page/map sending to another process
	- sleep/wake entities/pages/maps
	- Loop issue in map-step: http://pastebin.com/fFrwmKA6
	- Page stepping << Map stepping???  (possibly set pages to sleep?)
	- Fix camera (currently resets every frame)
	- Fix clicking to attack enemies (in lots-of-npcs maps?)
	- Recycle Tile
	- UI: Defer updates when too much time already spent in UI (round-robin update? webworkers?)
	- UI: Hide/Redraw/Show html (to avoid redrawing after every css/html change)
	- Clean Profiler mess
	- Clean update/step mess
	- Player send path (or path progress) rather than walk (inefficient otherwise). Make note of possibility of compressing (dir/dist pair compressed into 1 byte, then path is a string of walks)
	  	- NOTE: NEED To identify map (otherwise if we request a path which has a similar starting point to another map, and we happen to zone into that map on the server right before the request comes through..weird shit happens)
	- Clean pathfinding + partial progress mess
	- Show "Still logged in.. can't login"
	- Idle (animation) goblins when they get bored and finish walking back to spawn
	- Debugging:
	  	- Print current brain/neuralnet
		- Draw current path (pos/dest & path + actual path written out on the right + recalibration)
	- Neural network fixes
	  	- Provide interface to neuralnet: get, has, remove
		- Interface to neuron: property (es6 getter/setter)
		- On any changes print out current neuralnet state
	- Fix: movement new chase calls stop on previous movement which calls cancelPath EVERY time (and broadcasts event to everyone) 
	- Ranged combat
		- Ranged attack (vs. melee) -- show sprite
		- filterFunc:
		  			- Option 1: Circular tile expansion, considering collision along expansion
					- Option 2: Use precomputed Manhattan heuristic to determine each endpoint which could be reached, and their starting points. The paths between start to end will share common ancestor paths (NOTE: This means we HAVE to have each endpoint always take the same path which correctly shares its ancestor path). We could go through each ancestor path (beginning part) and see which tiles are accepted/unacceptable, then spawn the child paths if accepted, and continue on for however long the range is. 
					  			Actually we could spawn from the multiple different ancestors in certain cases.
								Rule: Only allowed to follow 2 cardinal directions from startpoint to endpoint, from the startpoint we cna travel 1 direction for a max of X distance, but the first turn disables that and we have to make a turn every tile after
	- Fix: entity uses alternate path which takes a completely different path; then path way through the new path (at a point which is much further away than the server position) the entity walks off in another direction. CurPosition & path start position could be drastically different
	- Fix player attacks goblin 2 tiles away.. both walk towards each other and end up on top of each other  (on evt move could be worth it to check if you could recalibrate to previous tile)
	- Fix goblin bored walking back doesn't have sight enabled (ignores users running beside them)
	- Setup build pipeline, concat, uglify, minify, SourceMaps, babeljs, jslint/eslint/jsint/jscs, smoke test (Jasmine?), flow
	  - Testing: use various test scripts  (NOTE: there should be test maps for test cases so that we can isolate individual test scenarios)
	        0:00:00 - Jasmine( world.maps['main'].movables[1].move(4, NORTH) )
	        0:04:00 - Jasmine.assert( movable[1].position.y == 4 )
	- eslint: spaces (4x)
	- server.js: clean requirejs (should only require once)
	- Logging: output to file, UI, colouring, store in buffer to flush together (or only print if a crash comes up)
	- CLEAN: spam clicking movement lags out the entire game (server should ignore noisy players; client should temporarily ignore input between processing); should probably also have client-side check if the near-path has even changed, then only send the later part (updated) path when necessary
	- CLEAN: clicking to move while zoning (disallow)
	- CLEAN: remove server animations; auto client animations (facing target, etc.)
	- CLEAN: Movable setting params before/after Ext
	- CLEAN: player/NPC moves to edge of new page; they are still able to attack across pages, but this may cause issues for other clients who don't have the other page/movables in memory
	- CLEAN: renderer.js, rendering page & sprites & movables; render only visible portion of pages; clean static rendering; abstract rendering operations
	- CLEAN: rendering (set base tile, and sparse sprite/base/items/movables (obj w/ key as coordinate); each tile contains the tile_id and a reference to its sheet)
	- CLEAN: convert server tiles to Uint8Array; each references an index of tileRefs which specify the gid; cache and send page data as a blob (for compression/throughput)
	- CLEAN: switch from loops to maps/forEach/...
	- CLEAN: clean up Promises:   Promse.then(...).then(...).then(...).catch(...)
	- CLEAN: fix up .call .apply .bind for performance: http://jsperf.com/function-calls-direct-vs-apply-vs-call-vs-bind/6
	- CLEAN: replace .hasOwnProperty: use property access (eg. obj['id']) which is significantly faster; unless we can expect undefined/null/0 then use `in` (eg.  id in obj)
	- CLEAN: switch parseInt w/ Math.floor where necessary: https://jsperf.com/math-floor-vs-math-round-vs-parseint/
	- render background canvas as ALL neighbour pages; then simply translate the canvas as you walk around (NOTE: drawImage on background takes up the most CPU in profiling; this would fix that completely)
	- server & client initialize gid's separately (in arbitrary order), and then server overwrites client gid for necessary tilesheets. So king sheet has same gid.first as items.sheet in house since house doesn't overwrite items.gid. SHOULD precalculate all sheets gids' into sheets.json
	- Safe spot: if entity logs in or respawns to bad tile, relocate to the safe spot instead
	- Server jump to client's current path position (ie. server receives client path 0.1s later, so jump to the position that he should be at)
	- Client path out of sync: speed avatars up when too far, otherwise teleport
	- Clean commenting style (top of file/class, splitting between members/public/private properties of classes, methods)
	- Resources.js using 'dist/' directory, should abstract this
	- http://bluebirdjs.com/docs/install.html : look at node installation debugging techniques
	- Tool for .myquest-globals.json (js script to load globals json, go through game to get keys & "GLOBALS['...']=", add keys if not found in globals, then write to globals)
	- player.disconnectPlayer()  should unhook everything which may be listening to it.. "Entity page does not contain entity" when user attempted to d/c while a bunch of npcs were attacking
	- server.js: Make players an array; also improve eventBuffer (object of mapID, pageID)  should be arrays. Perhaps we could map  (map,page)  pairs to indices which the player could contain? Although maps will soon be threaded anyways
	- Look into https://www.joyent.com/node-js/production/debug for debugging techniques    http://stackoverflow.com/questions/1911015/how-do-i-debug-node-js-applications/16512303#16512303
	- Assertion testing: find a good assertion library (should be easily extendable, readable, minimalistic, compatible through browser+node using native assert) and find a way to easily remove (or disable) asserts from prod. eg. `assert(XXX)` ==> `if (!prod) assert(XXX)`. Assert ALL type checking on functions as much as possible; how to coordinate this with if(XXX) throw Err ??  We may want some asserts to remain in prod and only most of them to be in debug
	- Add option to disable asserts in production.. NOTE: NEED To either remove asserts, or prepend (if !prod) to them, otherwise it'll still call the expression before calling the assertion
	- Confirm that we can remove onEntityWalking, and focus entirely on onPathProgress
	- Fix hooks to not require context (could use arrow functions intead)
	- CLEAN: switch from errorInGame to shutdownGame to shutdown server (unless there's an error)
	- assert(HiddenClassChecker(1, arg), "...")   .. HiddenClassChecker uses the caller/num as an identifier, then checks every property of the arg to determine if the last recorded arg had the exact same hidden class (otherwise throw)
	- Area vs. Region?
	- Aggro: attacking one person then another person walks right beside you, you ignore them
	- Client pathfinding - prefer to move the same direction you're already going (weight of +1 for immediate turn)
	- Loggable time; also allow server to extend messages with time (or ID) and client can print out received event (time/id) before handling
	- Client loads serialized page/movables w/ path in progress and disregards current walked amount; should shorten walks by amount that has already been walked (to avoid entity walking more than necessary)
	- Fix Strategy loading/handling in combat (be conscious of memory); should be able to abstract functionality; should be able to extend w/ Logs
	- 2D spritesheets out of 3D models
	- 2D texture synthesis https://github.com/mxgmn/WaveFunctionCollapse  https://github.com/mxgmn/SynTex
	- Can we remove 'static' property? A bunch of scripts are using them but doesn't seem to do anything
	- Script initialize should pass itself as the 1st parameter to allow initialize as an arrow function (this context to be what we expect)
	- "use strict"
	- if checks on north/west/south/east have an else case and throw error
	- AbilityState vs Instinct?
	- Path Sync: If receiving path for an entity that's out of view, and the path position is also out of view, then teleport entity to that position
	- Update "var" to let or const (lots of files still using var)
	- Path/Walk destination tile (some places are using it, some aren't.. need to either go all the way and do it or not at all)
	- Merge walks w/ same direction (seems to be more than recalibration; and messed up locally)
	- On crash dump as much debugging details as possible (.dump() for entities, characters, etc.)
	- Cancel character path on respawn: Is this a good idea?
	- Clean ServerHandler response from server (loops through entire event archive from 0..n, this seems unecessary)
	- Scripts are being loaded twice on startup: client/game.js initialize, then loadAreaIntoGame.. Find a way to only load once on startup
	- Debugging
	  	- Open Chromium for bot/server debug (exec chromium)
		- Run bots with both --inspect and debug to auto break on debugger statements, but also leave room to debug through dev-tools later
		- Error Report: Webpage that takes a report.json and displays it accordingly
		- If live: email error reports to me
		- Error Report: Fix dumps, and add dumps to *EVERYTHING*
	- Cleanup player requests / error checking
	  	- 1) Confirm we have expected and valid args
		  2) Call handler: handler checks valid args, then attempts to run
		  If there is any issue in the handler or caller respond to the user with the err msg and return false; do NOT allow subroutines to throw errors, check input before then
		  Need a routine like,  confirm( [dataAssertion], "Invalid argument" )   where confirm acts like an assertion and auto responds to player evt
	- Smoke Test
	  	CLIENT: bot.js (loaded via Karma)  should load Game as expected (strip renderer/ui)
			- Read from some test file
			- Server takes in arg to specify that its for testing. If testing then load test world (NOTE: want to do all startup routines at beginning to speed testing up). Extend Player class to accept args from Bot (if in testing mode) rather than loading/saving from DB. Otherwise maybe we could have a test DB/Redis?
			- Bot loads test file, sends necessary args to server, then runs through test cases
			- Server should run at varying speeds to allow quick testing
			- Can we make it so the bot can load/reload in the same instance? eg. new player / map / etc.   without reloading base modules?
				- Maybe we can have Test framework load base modules, then individual bots under the Test framework are loaded/unloaded as necessary. This way we can also have multiple bots doing things in parallel and even interacting with each other
	    Testing: use various test scripts  (NOTE: there should be test maps for test cases so that we can isolate individual test scenarios)


		- Fix error reporting in bots (throw)
		- Setup test resources
		  	path/recalibration, signup/login/logout (also double logins) + chat
			- rock-recalibrater: spam click around a rock that's between pages
			- page-running: runs between neighbouring tiles on the corner of 4 pages
			- zoner: zones in/out
			- train: many bots running through large map (lots of ents)
		- Bot interface to Game/test
		- Close server test websocket
		- Test framework: Loggable
		- Test framework: Do base module loading here instead of on bot
		- Bot: Move renderer/ui and clean
		- Clean Client/Server testing overrides (messy testing stuff)
		- Bot: Debugger option
		- Bot interface + tons of tests
	        0:00:00 - Jasmine( world.maps['main'].movables[1].move(4, NORTH) )
	        0:04:00 - Jasmine.assert( movable[1].position.y == 4 )
		- Need to find a way to organize bot logs
		- Integrate into Grunt
		- Integrate Mocha
		- Fix error reporting
		- Abstract stacktrace/error report from client/server/bots
		- Timeout on tests
		- Consider multiple bots running at the same time: most importantly would be one bot loading or zoning into a page or map where another bot is already doing stuff (running around, attacking, etc.)

		- Debugging:
	        - Area draw map; server.test should be able to return pages/data to test framework, and bot can draw both maps side-by-side to show differences
			- Store history of paths for entity: path id/flag, to/from, received path and current state (if client); print this out nicely, potentially with visuals (tiled on left, and zoom-in of recalibration on right)
			- Enable log buffering on client
			- Add times on logs (min/sec? no need for large timestamps)
			- Make requests to server for history of paths on entity; log timestamps (between ranges)
			- When bot (or server?) crashes, enter interactive console to allow debugging (eg. printing path history, etc.)


	- BUG: If you're queued to d/c and then die before you have a chance to d/c, your queued request will still trigger and crash the server (since dying removes your player from the map and the d/c attempts to get your character)
	- BUG: Start test bot then load in part way through; when receiving PathCancelled messages and bot is out of sight shit gets crazy
	- BUG: Client throw Err doesn't actually print thrown message, just "uncaught exception"  eg. server handler functions (onPathCancelled)  (temporarily added console.error in Err class)
	- BUG: Disconnecting player says, "Successfully updated player (5) position"
	- BUG: Bot: server adds path for player which has its own onFailed function so we lose our onFailed callback
	- BUG: On browser when running bots, open console and notice the lag, then we start hitting "Recalibration is longer than our maxwalk"; try suppressing logs to see if that fixes lag, and also turn this error into a warning
	- BUG? Clients should not set combat/melee target since server paths will take over and cancel your current paths thus resetting the target
	- BUG: UI offset on entities (possibly due to old page and local offset?)
	- BUG: DB saves position without open tile checking
	- BUG: Suppressed logs w/ LOG_INFO aren't being logged afterwards
	- Check Promise/Deprecation errors:  --trace-warnings --trace-deprecation
	- Roaming bot: preprocess map to build a nav graph; have the bot go between nav points on graph to satisfy his roaming goal
	- BUG: Recalibration (working but need to finish)
		- Merge walks (note: need to coordinate with ordering recalibrations too. eg. recalibrate north, recalibrate east, path goes south):
		  	1) Prune walked walks
		  	2) Take the 1st (non-walked) walk of the path and subtract its distance from the recalibration + add to that walk distance -- NOTE: This should ONLY be on the recalibrationEnd recalibration
			3) Path.PushWalk(..)  which unshifts the new walk or otherwise merges it with the current front of array walk
		- Fix walks of 0 distance (probably because walk.walked == walk.distance)
	   - Max Path check (used to be maxWalk)
	   - List ideas for avoiding spam clicking: request timout (spam click 3x, each path request replaces the previous and the most recent one is used during path check), path check cache (point A -> B checked and cached), map regions (convex hulls) then cache path checks from region A -> B. Otherwise we could accept all paths from people and simply cancel them if they're about to move into a collidable tile (this also helps with dynamic tiles!), then remote players could check the path for collision and if there's a collision simply walk up to that point?
	   - Complex test: Have variable number of bots zoning in/out of house
	- Change item "types" to "attributes", and add a "type" property for abstracted data: eg. "potion" has stack == 8, has attributes "USE" and "PICKUP", etc.
	- Try converting AOE triggers into circles added to a trigger list in each page; then just listen to EVT_MOVE_NEW_TILE on the page and check the position against the point/radius
	- Get rid of .before on hooks, and just have a 'hookX-pre', 'hookX-post' instead for those specific cases
	- Look into if V8 uses symbol tables for strings, or should we implement this? (particularly necessary for hooks in fast str cmp)
	- BUG: Change SCRIPT.INJECTION, ./grunt doesn't update all scripts
	- Respawning/Zoning should fadeout, then fadein when all scripts have loaded and are ready (mostly so that we don't see UI flicker); Also should pause renderer
	- Look into possibility for utilizing netSerialize/netRestore for dynamic changes on character without having to send events
	- FIXME: Fix SetAsPlayer() on server -- script/game.js calls this everytime the character enters an area, resulting in restoring and re-hooking and other initialization stuff which is unecessary. Should be setting player outside of this, on login. Currently using .initialization to prevent multiple reloads
	- FIXME: Find a better name for charComponents on character. We can't use components since character is a script and depends on components (see scripts/game.js using components)
	- Cleanup component serialization/restoring, currently its an array on character but object in db/netSerialize, and we have to find the component name by npc index. Overall gross and needs some cleanup
	- FIXME: Cleanup server login control flow to create your character before sending you character info, that way we can netSerialize your character rather than send your serialized db state -- afterwards would be nice to remove netInitialize and use netRestore instead
	- Look into async/defer scripts: https://bitsofco.de/async-vs-defer/
	- Merge Character/Components netRestore and restore common code somehow (sucks to duplicate code)
	- Buff Fading: Death sickness fade (slowly regain con/curMax health) :: fade/tick, send BUFF_MODIFIED_PRIVATE to client
	- Look into image rendering tricks for building anims: https://css-tricks.com/almanac/properties/i/image-rendering/
	- FIXME: ToolUI.effects tooltip can't get height while its not visible
	- Abstract loot into a character component for npcs
	- Buff stacking
	- Add an icons json; allow spritesheets
	- Look into a better solution for Components referencing The.scripting stuff
	- Fix server synchronous error reporting: currently sync because if the server crashed and writes, it exits before finishing writing and therefore ends up wtih empty reports. But sync is completely unecessary if the server isn't crashing (for client/bot reports)
	- Fix interactables: currently we invoke from Resources interactables list, which runs new every invocation. We should only instantiate the base once, then treat it as a static from then on
	- Fix catch on requirejs errors (OR switch to another AMD loader, but still need to catch on script errors)
	- QUESTS: How to handle events which affect later quests? Perhaps the quest could be opened/initialized, and then store the questkey or flip some flags in order to 
	- Quests/Interaction: Client side execution for nodes (eg. killing boss npc, "You feel the evil spirit has disappeared")
	- Quests/Interaction: Abstract conditions/executions between interaction/quest (and other stuff later); perhaps some scripting functionality (similar to The.scripting)
	- Quests: Listening to other events on character (certain NPCs could have an array of events they trigger on character that kills them; how can quests listen to that? should we save those event keys on questmgr in case later quests depend on it (ie. not needing to kill some boss character again after initiating the quest)).. To prevent unnecessary over-listening, we could instead emit EVT_QUESTKEY with some value which the questmgr forwards to the corresponding quest
	- Quests: If quests need to listen to events independently: Might need to store non-active questing stuff in db, and only load quests when necessary: quest node isn't listening to anything, so only load quest into component when we talk to guy. We can improve this later to only load quests from db when we enter the map which affects this quest, or only load parts of the quest from the db as they become necessary (eg. list of steps in the quest which I've achieved)
	- Interaction: Conversation shows in UI; able to select options (text on top, spacing, then links underneath for responses)
	- Interaction: After running an action don't display dialog options again (ie. repeatedly clicking the interactable shouldn't flood your messagebox with the dialog)
	- ExportMap: Support new data format (zlib compression, currently using CSV)
	- Interaction: Hook interaction fsm into interactable
	- Periodic saving: look into partial saves on dirty components for characters; and saving all players at once. Dirty position when you near a new "safe" checkpoint?
	- Projectiles: Add shooting bone/offset from archer's sprite
	- Projectiles: Find a better way to determine if the attacker is firing a projectile, and the projectile type
	- Projectiles: Better time-to-die calculation for projectile (per projectile number?)
	- Map Exporter: If tileset was not embedded in the map (eg. we imported or saved an external tileset) server/area.js cannot read external tileset
	- Sprite state (anim) should be maintained on the server. This is sent to clients when they zone in, and prevents from seeing sprites which are attacking when really they're in the middle of attacking
	- Pack/Compress/Encrypt resources (in case any are purchased)
	- Look into tossing pathfinding / other stuff onto another thread (child process); child processes can access parents, can this help with executing event callbacks?
	- Can we netSerialize once on changes, cache the results, and send those cached results to everyone on changes? Or should netSerialize only be done on initial load
	  	- would RMI a netSerialize w/ flags indicating what members have changed
    - Rendering background: could probably render each page background to a hidden texture/image/canvas, then when redrawing the background just render each prerendered page to one canvas; moving around the map only involves moving the background canvas. Zoning into another page could involve asynchronously rendering to a buffer background, and then switching the two background canvases when its ready
	  	- Cleanup
	  	- Async render (for new neighbours and buffer background)
	- Storing assets: encrypted assets; should pack things together (for now; later we could look into packing things that would likely only change together, or otherwise keep packs small so its a short download); compression; headers in packed assets
	    - CacheBuilder
		    - png -> webp
		  	- --recache option
			- Compress
			  	- xor image directly
				  	- cannot directly include sharp in browser (uses a .node binary file; so cannot bundle)
					- this will decompress image, xor it, and compress it. If we use a lossy compression then this WILL lose data from the xor. Need png or other lossless format
			- Structure images/sounds/data/etc.
			- Gruntfile watch for changes to raw assets / cache file; rebuild cache
		- Client
		  	- Works for headless (server/bot)
			- Async
			- Decrypt
			- Uncompress
			- Structure images/sounds/data/etc.
			- Webstorage; check for changes
		- Update git w/ cachefiles
    - Sheetedit: adding a new tilesheet but not setting any data yet (no collisions/floating/etc.) results in no data object, which crashes startup
	- Consider crypto for cache. Not necessary, but kind of nice security..although it CANNOT be too slow, otherwise its not worth it
	- Adding new tilesheet/spritesheet ==> automatically add empty cache; OR merge cachefile and sheets file
    - game.chat player zones out, loses admin commands (locally only?)
	- /teleport zone to another page that we already have: we should only fadeOut if we're teleporting to a spot where we'll be near neighbour pages that we don't have yet (need to wait for onZone pages). However, if we teleport like 3x tiles away that happens to be on another page, that probably doesnt warrant a fadeOut
	- ctrl+c kill not working; or resulting in bug in errorReport
	- /teleport to another area


	- Browser Debugging Snippets
			var scaryTiles = [];
			for (var x=13; x<=17; ++x) {
				for (var y=27; y<=30; ++y) {
					if (The.area.isTileOpen({x,y})) { scaryTiles.push({ x, y }); }
				}
			}
			var times = 200;
			var doTheDance = () => {
				var randTile = scaryTiles[Math.floor(Math.random() * scaryTiles.length)];
				The.user.clickedTile(new Tile(randTile.x, randTile.y));
				if (--times > 0) setTimeout(doTheDance, 120);
			}

	- BUG? What if client / local player zones then receives a delayed packet that we had a server path to remain in the page? (We should only process zoning stuff of adding/removing pages and movables when we receive the zone event from server; also will we teleport/walk back to position?) Something to look into/test later 
	  	

		[requires]

		[Comment] 

		[class]

			[members]

			[comment-splitter]

			[methods group]

	- Go through every file and clean with the following things in mind:
	  	- Error handling / throwing (Err)
		- Proper function/arrow function
		- Commenting on class, function, blocks
		- const/let
		- Logging as much as possible (error/warning/info/debug)
		- Class/Object toString
		- Functional coding
		  	- Array: every, some, forEach, map, filter, reduce, reduceRight,
			  		from/of/fill/copyWithin, for..of, find/includes, keys/entries, 
					destructuring
			- Map/Set, WeakMap/WeakSet
			- in, default param, rest, spread
			- Symbol: toPrimitive, iterator, hasInstance
			- Generators / yield
		- Promises
		  	- PromisifyAll, resolve, then/catch/finally
			- Collections: .each, .map, etc.
		- lodash stuff
		- Performance
		  	- for..in, copying objects: slow
			- hidden classes: make sure objects use the same hidden class
			  	- don't add dynamic properties
				- use the constructor only for objects
			- Arrays:
			  	- mixed types
				- holes in arrays
				- try to use arrays over objects
				- use contiguous keys (don't do  x[n] = 1; where n > x.length)
			- call functions with the same expected types
			- Strings are immutable
			- Only use `new Function()` if absolutely necessary


		Linted/Cleaned files list
		-------------------------

		js/main.js                                                ✓
		js/server.js                                              ✓
		js/client/game.js                                         ✓
		js/area.js                                                ✓
		js/client/area.js                                         ✓
		js/server/area.js                                         ✓
		js/pathfinding.js                                         ✓
		js/page.js                                                ✓
		js/server/page.js                                         ✓
		js/client/renderer.js                                     ✓
		js/scripts/character.ai.instinct.combat.js                ✓
		js/scripts/game.js                                        ✓
		js/scripts/character.js                                   ✓
		js/server/player.js                                       ✓
		js/movable.js                                             ✓
		js/client/ui.js                                           ✓
		js/scripts/character.ai.js                                ✓
		js/scripts/character.ai.combat.strategy.basic_melee.js    ✓
		js/scripts/character.ai.instinct.range.js                 ✓
		js/scripts/character.ai.instinct.movement.js              ✓
		js/scripts/character.ai.combat.strategy.js                ✓
		js/scripts/character.ai.combat.sight.js                   ✓
		js/hookable.js                                            ✓
		js/client/serverHandler.js                                ✓
		js/script.js                                              ✓
		js/utilities.js          								  ✓
		js/scripts/character.ai.instinct.bored.js                 ✓
		js/scripts/game.chat.js    								  ✓
		js/scriptmgr.js 									      ✓
		js/scripts/character.ai.combat.melee.js                   ✓
		js/serializable.js                                        ✓
		js/scripts/interactables.lookat.js                        ✓
        js/spritesheet.js										  ✓
        js/sprite.js                                              ✓
        js/entity.js											  ✓
        js/client/user.js										  ✓
        js/dynamic.js											  ✓
        js/client/page.js										  ✓
        js/client/camera.js                                       ✓
		js/animable.js											  ✓
		js/scripts/character.ai.combat.state.js                   ✓
		js/world.js        										  ✓


		js/scripts/interactables.talkto.js
        js/scripts/items.heal.js



========
  Been a while?
========

	== Been a while? ==
	
	A few reminders if you're just coming back after a while

	- Running game:
	   - ./grunt && ./grunt watch   # to watch the directory and transpile to the working directory
	   - node dist/server.js --test # run the server w/ test environment
    
	- Debugging:
	   - node --inspect dist/server.js --test  # open chrome://inspect to find the remote target and inspect it
		 									   # NOTE: If server hits a debugger statement, will pause there even if you don't have the inspector open yet
	
	- Admin:
	   - /admin 42

	- Troubleshooting:
	   - Client slow w/ web developer tools open
		 	- Disable breakpoints
			- Disable verbose logging

	- Mapping
	   - New map
		    - Orthogonal/CSV; 100x100 map; 16x16 tiles   # NOTE: Larger maps seem to be a problem, so trying out smaller maps for now
			- Tilesheets: Map -> New Tileset -> tilesheet   16x16
			  									npcs (tools/sheetedit/avatars.png)  32x32
			- Tile Layers: base, sprites
			- Object Layers: zoning, spawns, interactables
			- Add map
			  	- add map to world.json
				- run tools/export-world.json



Next Priority
	== Design
	- Stats/Resists, Experience, Loot; Exploring (npcs levels and where they're located in world)
	  	- Lower level creatures wandering around outside of camps; camps contain bigger creatures; bosses & special camps have long spawn times
		- 


	 - Level rewards (gain xp, statIncrease)
		- { "rewards": [ { "statIncrease": { "strength": 1 } }, "message": "You feel stronger" ] }
	 - Level XP loss calculation
	 - Health/Level/Armor/Dmg/AttackSpeed: stats (max, curMax, cur)   Also str/dex/con  for everyone -- use con for regen
	   	Skill in weapon? (warrior skill)

		str -- strengthen base damage                                   <-|  Str/Dex should be equivalent in terms of effectiveness
		dex -- larger damage range? (potential to hit for more damage)  <-|
			- able to crit
		wep dmg -- base damage
		wep spd -- attack speed
		speed -- improve attack speed
		skill -- improve effectiveness of str/dex/speed towards particular weapon type

		enemy AC, con




		Weapon Damage = Dmg * Str ^ X * [0.8,1.2]
			Dex: influences % of getting a higher score in the [0.8,1.2] crit range
				0.8 + (1.2 - 0.8) * (Dex / MaxDex) ^ Y
			X: Influenced by skill
			Dex: also influenced by skill

			E(Str=X, Dex=0) = E(Str=X-1, Dex=1) = ... = E(Str=0, Dex=X)

			Check the derivative of Str == derivative of Dex  (ie. rate of change is equal for both variables; and set peaks equal)
			

	 - Combat: smarter target selection
	 - Combat: attack/speed formula (level/stats/randomness)


	   Levelling
	   	- Level 1: 2 minutes to level (6 kills?)
	   Stats + Resists + Hinderances (eating/blindness/stun/confusion)
	   Items
	   Enemies / Toughness
	    Determine time-to-kill for each pair of levels (your level vs. enemy level), with expected health at the end (high/low health within 1/2 standard deviation)
		Draw out bell curve to determine direction (change between levels), and your expected damage + enemy expected damage at level
	   	- Level 1: 15 seconds to kill something at the same level; should finish with 60-70% health
		  		   Should be able to attack level 2, finish with 30-40% health  (30 seconds)
				   Attacking level 3, finish with -20-10% health (die in most cases)  (50 seconds)
		- Level 2: 10 seconds to kill a level 1; finish with 80-90% health; 10 seconds
		  		   25 seconds to kill a level 2; finish with 60-70% health; 

		 - Time to level up
		   	Level 1
			  - level 1s: 4x
			  - Level 2s: 2.5x
			  - Level 3s: 2x
		 - Time to kill
		   	Level 1
			  - Level 1: 5s
			  - Level 2: 9s
		 - HP after fight




	   Quests
	   Exploration

    - Map
        - Finish tidying area
        - Town
        - Figure out regions + npc placement; quests/story, etc.
    - Npcs
        - Stats, Items, Quests, XP, Sounds, Graphics
    - Improve 3d -> spritesheet pipeline & final appearance (color ramp texture OR final product?)
    - People / Dialog / Quests / Story


    - BUG: Off tile error (look into FORME_CRASH_OFFTILE)

	- NOTE: User logs in, server loads player from db and sends to player (no netSerialize since no character exists yet). NEED To netInitialize?
	- NOTE: User dies, respawns, after setting self to alive we call hook('respawning').post()  which triggers deathmgr to add death sickness (since we're now alive). Which means we'll send buff to user. The trick is to unload the buffmgr so the user doesn't handle the EVT_BUFF_PRIVATE evt





Future
	- Skills
	- Better interaction (right click entities/avatars, conversation tree)
	- Better UI
	  	- Store messages in localization files & packages which slot messages & UI effects into UI
	- Gameplay system/scripts, triggers/traps
	- Quest rewards: faction / opening up conversations with other npcs; epic quest; class quest; keys to locked areas (need key to get in, but lose key on death -- key quests should be weekly/different quests so you're punished for losing your key)
	- Groups or smarter XP (eg. people who assisted in killing, gave buffs, healing, etc.)
	- Animated static sprites
	- Multi-tiled movables (cthulu, boats)
	- boat: walk on & off, can't get off on water, walk on boat while boat moving, walk on boat while boat zoning (pages, maps)
	- dynamic collidables (drawbridge, shifting walls) -- NOTE: If we modify pathfinding such that clients send a full path, server broadcasts path without checking and everybody blindly accepts the path until a collision occurs, then they could halt from dynamic collisions. The server would only need to relay paths and broadcast halts, and could spend less timeprocessing paths
	- Entity idle animation
	- /admin
	- Electron desktop application
	- Replace Eventful w/ node.js native EventEmitter? (use Browserify event for browser)
	- Performance
	  	- Sleep/Wake entities/pages/maps
		- Cluster maps, use zeroMQ for IPC
		- JobList w/ Workers  (either self-contained processes)
		- WebRTC/UDP
		- db sharding
		- https://www.jayway.com/2015/04/13/600k-concurrent-websocket-connections-on-aws-using-node-js/
		- Chasing (pathfinding): NPCs can check player's destination tile and determine their own path (NOTE: Need to make it appear realistic, like the NPC is guessing where you're going, but able to optimize by only re-determining during changed paths, and potentially only if the changed path goes far off of where you would have met up with them anyways)
		- Pathfinding regions: open convex regions in map (able to immediately create [north,south]/[west,east] path w/out checking for collisions); could store "portals" (open edges) from regions and have cached paths between neighbouring region portals
		- Could store groups of convex collisions then connect a line to the nearest vertex and walk along the edge, etc.  like that one algorithm from computational geometry
 		- Trust player: only check for collision when player next tile changes (is your next tile about to be a collision?)
 		- Tile based: server only concerned about tile x,y; look at time since arrival at tile & possibly entrance into tile (left/right?) to help consider how much time to reach next tile; only update tileXY when that time has elapsed; send that tile reached time to other players so they can calculate real x,y; this must be completely synchronized though
		- Immutable arguments
		- Avoid for..in
		- JPS pathfinding for suitable maps/regions? (eg. dungeons, tight corridors)
		- Chasing (pathfinding): We can probably get away with only sending the target that we're chasing after rather than continuously sending updates paths (since our path continuously changes); or perhaps continue to use the same path and continue expanding on it assuming its a simple update (extending the end of the path rather than changing the path mid-way), then this is likely a deterministic operation that clients can be in sync with. We'd simply need to periodically send position updates of the movable if its been a while? Or path progress if its been a while?
		  - Write a module to compress EVT messages into arrays: { evt: EVT_GAIN_XP, data: { entityId: 54, killedId: 32, XP: 10 } }  ==>  [EVT_GAIN_XP,54,32,10]  then based off the event format table, reconvert it back to its object format
		  - Convert GainedXP, GainedLevel, Regen, etc. into Symbols, store in a global symbol table. If we make sure this is consistent between client/server then we could translate between symbol and id, then just pass the id in net code
		  - Look into canvas perf: https://www.html5rocks.com/en/tutorials/canvas/performance
	- Fault tolerance
	  	- On server crash, before stopping the process start a new server and tell it to restore from the current process (will need to recursively send/load everything) or otherwise for..of all recursively the members in the class; I wonder if there's a scalable solution to automatically register class members when declaring them on initialization (so that they're automatically able to serialize and load in the new process); process can probably be on a per-map (or group of maps?) basis so that if 1 map goes down the rest are still fine; then allow all clients on the crashed process to reconnect automatically
		- Could add preprocessors in "parent" functions which act as a safety check, eg. #CHECK( ExpectObjectFormat(data.args.container.s, { numbers: ForEach(IsNumber), evt: IsValidEvent }) )  on retail converts to:
		  		if (!_.isObject(data) || !_.isObject(data.args) || !_.isObject(data.args.container) || !_.isObject(data.args.container.s) || !_.isArray(data.args.container.s.numbers) || .....) { return } // Early out of function because of unexpected input, and log the error
			This sucks but would save us from any crashing
		- https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/  "Cached functions in the module pattern"  using mixins for classes which have many copies (eg. Tiles)
		- Consider cache misses and instruction misses in the compiled code from the JIT, and ensure that we're minimizing those by reusing the same codepaths and objects in the same places (ie. batch processing with minimal instructions, or, SIMD type coding)
		- Look into webassembly, or C++ based modules for the server to run perf-intensive code
	- Debugging/Testing
	  	- Agent bots which follow player around, have sight to attack nearby enemies, use precomputed waypoints to catch up to player (if died)
	- Tracking variables during stack unwinding/crashes: could have a preprocessor go through scripts and recognize all variable assignments in scripts, then append global['STACK.FUNC.var']=var
	- Look into WebAssembly components for high performance operations (eg. pathfinding)
	- FXMgr:
		entity type + traits (HurtGoblin, ArcherGoblin -> Goblin -> NPC -> Avatar); Each of these could have some settings, and the most derived types + traits override settings. Should be able to use this for everything not just sound
		Improve sound buffer loader: promise/load all, then set FX as ready when everything is loaded
		Utilize WebStorage to store/load sounds (need some way to determine if sounds have changed on the server)
		Conditions (new sound stops previous instance of sample? limit to X number of instances of sample? limit to X number of sounds on an entity? etc.)
		Sound groups (weapon -> combat -> world -> global); each group can have its own settings
		Effects -- positional nodes, impulse response (environmental effects) -- dynamic & settings; look into other effects/nodes
		UI Settings (volume)
		Music: Different areas trigger 'EnterArea', 'ExitArea' which trigger music to enable/disable. Takes some time to enable to full or disable completely. Draw trigger areas in map to define areas, have map exporter expand it out slightly more for an outside/middle/inside area (for better fading)
		Music fade: Cancelling current music (music -> null), Pushing Music FX when another instance of that same sample is already playing (if fading out then fade back in, cancel new push)
	- Bug system
	  	- Object Dump()
		- ErrorReport tool
		  	- Server/Client side-by-side
			- Logging colours
			- Header show error (should only be one)
			- Report list: "Report 05/02/2017 10:01 PM -- Client Report:  ASSERT: Cannot divide by 0"
			- Syntax highlighting on source
			- Select source line, loads code region (NOTE: may need reports to include git details, so we can load file from certain timeframe)
			- Interactive JSON for client/server dumps (highlight dump region a different bg colour depending on client/server)
			- Get rid of source parse from game errorReporter, integrate entirely into tool w/ git support
			- Setup grid for error stack (Chrome 57)
			- Log: if JSON then prettify log
			- Code region: Button to left of code area to expand into full source code (centered about line) fully highlighted
	- Admin commands from client -- to open server REPL
	  	- Request login to server
		- Commands
		   - Set health/stats (cur)
		   - Drop items around you
		   - Put items in inventory
		   - Add buff
		   - Godmode
		- Enable admin on login
		- Twitter plugin for autocomplete




========
 Pathfinding Perf
========
	- l1-clarkson w/ option to turn on/off; best from/to tile
	- compress path/walks
	- get rid of JPS (turn off)
	- Start path from last point
	- Only search every X turns (dependant on how far the player is)

	- http://www.redblobgames.com/pathfinding/l1-clarkson/
	- https://github.com/mikolalysenko/l1-path-finder
	- http://www.redblobgames.com/pathfinding/visibility-graphs/
	- http://www.redblobgames.com/pathfinding/heuristics/differential.html
	- http://www.redblobgames.com/pathfinding/tower-defense/
	- http://www.gdcvault.com/play/1022094/JPS-Over-100x-Faster-than
	- Start path from last point
	- Only search every X turns (dependant on how far the player is)



10:20 < jbud> amitp: You around??
10:21 < jbud> I have a couple of qs's regarding your JPS article, if you're around :)
10:21 < amitp> hi
10:21 < jbud> There's something I'm really confused on that never seems to be mentioned in anything with JPS
10:21 < jbud> Big maps
10:22 < jbud> In particular, big open spaced maps
10:22 < jbud> JPS basically just traverses up, for every tile, and checks all of the tiles on the left/right to find any jump points
10:22 < jbud> But for big maps that's potentially extremely inefficient
10:23 < jbud> I thought I could sidestep that by precomputing jump points offline, but I think you have to do that traversal process just to find the goal
10:25 < amitp> Yes, it is potentially inefficient
10:25 < jbud> I think the worst case is something like this: http://qiao.github.io/PathFinding.js/visual/   leave it as default and run JPS, EVERY tile has to be traversed before it finds the goal
10:25 < amitp> There is a JPS+ algorithm that precomputes some things
10:25 < amitp> Although I do mention JPS on some of my pages I don't use it myself because I find it to be a strange algorithm
10:26 < jbud> Because of the same issue?
10:26 < amitp> That and many other issues :(
10:26 < jbud> =[
10:26 < amitp> JPS is popular though so I should try it someday
10:26 < amitp> I have never implemented it myself
10:26 < amitp> (I'm not sure which "your JPS article" you're referring to)
10:27 < jbud> I feel like A* should work for me, but I'm probably using it the wrong way. The problem is when I have 100 enemies chasing a player, and every time that player moves to a new tile their path has to be recomputed from 
              scratch
10:27 < amitp> You can either modify the algorithm (A* into JPS) or you can modify the data structure (grids into navigation mesh or visibility graph) and I usually change the data structure instead of changing the algorithm
10:28 < amitp> Have you considered breadth first search?
10:28 < jbud> No,that's kind of weird isn't it? A* has a heuristic but BFS doesn't
10:28 < amitp> http://www.redblobgames.com/pathfinding/tower-defense/ -- when you move the player (the red blobby icon) you have to recompute the paths, but you only have to do that once for the player move, not once per enemy
10:29 < amitp> How big is your map?
10:30 < jbud> Wow this looks really interesting
10:30 < jbud> I'd like to have maps as big as 300x200 tiles or so
10:31 < jbud> Maybe larger. At this point I'm just aiming for scalability in the engine
10:31 < amitp> 300x200 I just use regular A*
10:31 < amitp> but if you have 100 enemies and they are all goign to the same player then breadth first search
10:32 < amitp> Breadth first search uses a queue instead of a priority queue, and queues are much faster. I think you'd be able to compute the whole thing in 1 millisecond for a 300x200 map, and you only have to do that every time 
               the player moves.
10:32 < jbud> That's actually really awesome
10:33 < jbud> Another problem though is if more players join the game
10:34 < jbud> And those computation times add up
10:34 < amitp> Yes
10:34 < jbud> One idea I was toying with is defining a boundary between the player and enemies everytime the pathfinding is computed
10:35 < jbud> The path would have to reside within that boundary, BUT it avoids searching parts of the map that are unecessary
10:35 < amitp> There's a trick for making queues even faster, but it only works with breadth first search. I should write a page about that. The idea is that you have two arrays, A and B. When you are expanding the nodes from A, you 
               put all the neighbors in B. Then you set A = B; B = []. This way you remove lots at once instead of removing one item at a time
10:36 < jbud> I get it
10:37 < amitp> I have regular A* http://www.redblobgames.com/pathfinding/heuristics/differential.html running pretty fast (as you move the mouse around), and I know breadth first search would be faster, but I haven't tried it on 
               that size map. I will add that to my list of things I should try :)
10:39 < jbud> Also do you think its reasonable to recompute paths starting from the last goal point?  So if the enemy has a path to the player, then the player moves 1 tile away, to have the pathfinder run from the previous goal to 
              the next goal?
10:39 < amitp> It is reasonable but you don't need to do this unless an enemy is close to the player
10:40 < amitp> If the enemy isn't close, wait a little bit, because you know the player is going to move soon
10:41 < jbud> Okay, thanks amitp  I'm going to read through these articles. I really like the performance you're getting for these
10:42 < amitp> The data structure for the graph and the priority queue make a big difference. I usually use a binary heap for the priority queue.
10:43 < amitp> I usually use an integer for the node id instead of an object. For a grid something like (y*1000 + x) can be a reasonable integer id. The four neighbors will be id-1 id+1 id-1000 id+1000.
10:44 < jbud> See I was surprised people mentioned the priority queue as being a problem. I just used something like:  queue = {}; queue[heuristic] = array(neighbour1, neighbour2, ...);  then the node with the lowest heuristic is 
              just the first element on the queue, so    var cheapestHeuristic = null; for(var heuristic in queue){ cheapestHeuristic = heuristic; break; }
10:45 < amitp> Hm, interesting
10:46 < amitp> I don't know how javascript represents that, but since that type of array is not a common use of arrays, I suspect the optimizers don't optimize sparse arrays that don't start at 0
10:46 < jbud> True its an object instead of an array
10:47 < jbud> But I think it uses a hash to fetch elements, so O(1)
10:47 < amitp> Even a hash can be slow ;)
10:47 < jbud> Tbh though I might be wrong
10:47 < jbud> Yeah =[  I really need to profile that and figure out for sure
10:49 < amitp> For my demos I'm using mikolalysenko's simple-heap library
10:49 < amitp> https://github.com/mikolalysenko/simple-heap
10:51 < mikolalysenko> minimizing priority queue operations is the main advantage of jps
10:51 < mikolalysenko> it still expands many nodes in the grid, but the trick is that it only puts a few special jump points into the priority queue
10:52 < jbud> Right but for large maps traversing all of those nodes could outweight the time spent handling priority queue operations right?
10:52 < mikolalysenko> it might
10:52 < mikolalysenko> jps is a bit funny
10:53 < mikolalysenko> basically it amounts to searching on a reduced graph where the nodes of the graph are the corners
10:53 < mikolalysenko> and to query an edge you have to do this weird jps expansion thing
10:54 < mikolalysenko> you can speed it up by precalculating a visibility graph like amitp does in one of his tutorials
10:54 < mikolalysenko> but the downside to using a visibility graph is that there can be up to O(n^2) edges, where n=number of corners in the grid
10:54 < mikolalysenko> you can reduce the number of edges in a few important cases though
10:54 < amitp> http://www.redblobgames.com/pathfinding/visibility-graphs/ is my visibility graph demo
10:55 < mikolalysenko> if the objects only move along cardinal directions (n,s,e,w), then you can add some steiner points to reduce the number of edges to just O(n log^3/2 n)
10:55 < amitp> In practice though I find grids, with good graph and priority queue data structures, to be plenty fast enough for me.
10:55 < mikolalysenko> depends how big the grid is though
10:56 < amitp> Right, and none of my projects have huge grids so it is fine for my stuff :)
10:56 < mikolalysenko> if you have a really big grid, you could try this module: https://github.com/mikolalysenko/l1-path-finder
10:56 < amitp> jbud has a tiny grid
10:56 < amitp> l1-path-finder is awesome
10:57 < mikolalysenko> there are some demos on this page http://mikolalysenko.github.io/l1-path-finder/www/
10:57 < mikolalysenko> if you click on the logo at the top the circles will chase your cursor around
10:58 < mikolalysenko> all paths in that demo are recomputed in real time, and they run on a grid ~ to the size of your display
10:58 < mikolalysenko> so it is 1 pixel/grid cell
10:58 < amitp> I tried one of the biggest maps I could find (800x800) and l1-path-finder took essentially zero time http://www.redblobgames.com/pathfinding/l1-clarkson/
10:59 < jbud> omg
11:00 < mikolalysenko> you could modify l1 path finder to work with linfinity paths too
11:00 < mikolalysenko> since you can convert l1 distances into linfinity distances by shearing
11:00 < mikolalysenko> so this would be situations where you have diagonal movement
11:01 < mikolalysenko> the trick in l1 path finder is based on an idea by ken clarkson
11:02 < mikolalysenko> he originally invented it for vlsi design/synthesis, and his original version was somewhat more general
11:02 < mikolalysenko> since it works with arbitrary polygonal obstacles, not just grids
11:04 < jbud> This is really cool mikolalysenko 
11:04 < jbud> Seriously it runs crazy fast
11:04 < mikolalysenko> thanks
11:05 < mikolalysenko> I made some benchmarks to compare it to other js libraries
11:05 < mikolalysenko> https://mikolalysenko.github.io/l1-path-finder/benchmark.html
11:06 < mikolalysenko> though part of the problem is that many of the js path finding libraries out there are really really bad
11:06 < mikolalysenko> so none of them put up much of a fight
11:06 < mikolalysenko> other than l1-path-finder, the best I've found is pathfinding.js and it is really bad
11:06 < jbud> Yeah, it looks like you put easystart to shame
11:06 < mikolalysenko> easystar is terrible
11:06 < mikolalysenko> horrible api, lots of bugs, really really slow
11:07 < mikolalysenko> please never use that library
11:07 < jbud> Hahah I won't, np
11:08 < mikolalysenko> like look at this mess:  https://github.com/prettymuchbryce/easystarjs
11:08 < mikolalysenko> why are there 20 methods here?
11:08 < mikolalysenko> what is going on?
11:08 < mikolalysenko> and there are lots of async/zalgo bugs all over the place
11:08 < mikolalysenko> just ugh, don't touch that thing
11:08 < mikolalysenko> so dishonest calling that thing easy
11:08 < mikolalysenko> and it is absurdly slow too
11:09 < jbud> Loll
11:09 < jbud> Poor Bryce, I hope he doesn't see those benchmarks
11:10 < mikolalysenko> well, at least he has like 1000 stars on github so I guess that is something
11:10 < jbud> Holy shit he does!
11:10 < jbud> That's a bad sign
11:10 < jbud> People really shouldn't be using that library if it runs that slow
11:10 < mikolalysenko> and it is broken
11:10 < mikolalysenko> like seriously fundamentally broken
11:11 < mikolalysenko> as in you get callbacks that don't fire, fire twice, fire with incorrect/corrupted state
11:11 < mikolalysenko> it gives paths that are incorrect
11:11 < mikolalysenko> etc.
11:11 < mikolalysenko> pretty much the worst library
11:11 < mikolalysenko> 0/5 would not recommend
11:11 < mikolalysenko> pathfinding is at least pretty solid, but it is just slow
11:11 < jbud> That's really sad, I picture people trying to make a game and look for the most popular pathfinding library on Github. Come across that and implement it, wondering why their game is so buggy
11:12 < jbud> Then just giving up altogether
11:12 < mikolalysenko> this one is actually the most popular:  https://github.com/qiao/PathFinding.js
11:12 < mikolalysenko> it is just very slow
11:12 < mikolalysenko> but the main draw is the visualizations I think
11:13 < mikolalysenko> if you judge the repo by the algorithms implementations, then pathfinding.js is also pretty bad
11:13 < mikolalysenko> however it has some really nice interactive visualizations
11:13 < jbud> Yeah its a good learning resource for sure
11:13 < mikolalysenko> one thing that pathfinding.js does which is pretty stupid is that it reinitializes the map every time you call one of the search algorithms
11:13 < mikolalysenko> which kind of defeats the point of things like A*
11:13 < jbud> That's weird
11:13 < jbud> Actually wth that's really weird
11:13 < mikolalysenko> yeah, and it is bad
11:14 < jbud> Especially for people who don't know that and use that for their game
11:14 < mikolalysenko> at least it mostly works
11:14 < mikolalysenko> yeah, don't use it in a game
11:14 < mikolalysenko> basically all of those algorithms run in about the same time as bfs in practice
11:14 < mikolalysenko> even their fancy over engineered jps implementation...
11:14 < mikolalysenko> but if you are just gonna zap the whole grid anyway, then *why bother*?
11:15 < mikolalysenko> you should just bfs it
11:15 < jbud> Hahah
11:15 < jbud> Yeah I don't get it, that should be an optional setting that's turned off by default
11:15 < mikolalysenko> pathfinding.js is kind of wtf
11:15 < mikolalysenko> but I don't think they seriously advocate for using it in a game or something like that
11:15 < mikolalysenko> it is really about the visualization
11:16 < mikolalysenko> they do expose an api, but I think that it was created as an afterthought
11:16 < jbud> I was going to argue that the main point of it was as a learning resource, but i tlooks like that's not the case
11:16 < mikolalysenko> the visualizations came first
11:16 < jbud> "The aim of this project is to provide a path-finding library that can be easily incorporated into web games. "
11:16 < mikolalysenko> yeah....
11:16 < mikolalysenko> don't use it
11:16 < jbud> Lol
11:16 < mikolalysenko> but it is better than easystar
11:17 < mikolalysenko> and easier to use too ironically
11:17 < jbud> True true, well I really like what you've accomplished with l1-pathfinder, and some of the tricks amitp has
11:17 < jbud> I spent so much time googling around for pathfinding tricks, I'm not sure how I didn't come across either of these
11:18 < mikolalysenko> amitp's stuff is the best resource on the net I think
11:18 < mikolalysenko> for grids anyway
11:18 < jbud> Yeah its really well written, good visuals and easy to follow
11:18 < mikolalysenko> if you are using triangular meshes, you should check out recast
11:18 < mikolalysenko> https://github.com/memononen/recastnavigation
11:18 < mikolalysenko> that is a really nice system
11:19 < mikolalysenko> I think it is used in many AAA games
11:22 < jbud> This looks pretty cool
11:22 < jbud> I'm gonna head off and read through these resources you guys recommended, thanks :)









 

SERVER
	* Updating server
		- major update:
		  	git branch vX
			git checkout vX   (or, git checkout --  to clear unstaged changes)
			git pull origin master
			update testingLocal in Environment.js

			kill processes (ps -ef)
			(update db)

			nohup ./runserver &
			(update jbud.me)

DB
	* Setup (from scratch)
		- use myquest   -- will create db myquest
		- db.players.insert({ id: 1, position: { y: 60, x: 53 }, respawn: { map: "main", position: { y: 60, x: 53 }}, map: "main" })

====== Promises

	* Promises only allow for 1 argument for .then(..); hence for multiple args wrap in { }
	* Not error safe; must throw and use .catch() on promise
	* .catch() will not be received from nested callbacks
		return new Promise() {
			Tacos.onFailedTaco = function(evt){
				throw new Err("Error failed to make taco!");  // This will not be caught by promsie catch
			};
		}
	* Continues on after calling resolve() or reject()  (must explicitly return after calling those unless you want to continue)

====== Eventful

	* triggeredEvents will append the event callback to the CONTEXT's event_callback_queue
	* REQUIRES an update function to handle pending requests regularly
	* Not error safe; must throw errors
	* Because triggerEvent loops through an array of listeners, you can only run stopListeningTo on the callback object during the trigger; however, if you run stopListeningTo on another object then this WILL break things. If this is a desirable feature later on, we can implement it by adding a "lastCalled" id to callbacks and readjusting the loop at each iteration to the next callback

====== Subscription
	
	* Essentially Eventful, but the Eventful is all handled within the scriptmgr and propagated to the script
	* Not error safe; must throw errors

====== Dynamic

	* Only ONE handler
	* Error safe: return Error and the caller will be able to handle it accordingly
	- registerHandler, handler set

====== Hookable

	* Can only have 1 (id, context) pair per hook
	* MUST provide context
	* Not error safe; must throw errors
	- triggerer: registerHook('name'), unregisterHook('name'),  doHook('name').pre|post()
	- listener: hook('name', this).before|after|removePre|removePost|remove()
	- Cleanup: make sure to run  hookable.unhook(this)  when unloading this  (eg. map.unhook(this))
	- Hooker Cleanup: if X is unloading then it needs to call hookable.unhook(this) on everything its hooked into; OR this.unhookAllHooks() for everything

====== Prototype

	* http://jsfiddle.net/vauovfyd/
	* Type A Prototyping: Essentially a base class, except that this base class is a Singleton (ALL classes using this class as a prototype will share the same properties)

	* https://jsfiddle.net/jc24s7b4/ 
	* Type B Prototyping: Essentially a copy of the prototype; other classes won't share the same context

====== Base

====== Scripting

	* Various scripts could be attached to an object in the Engine (eg. Character & Movable)
	* Engine object should NEVER listen to or access scripts

====== Script

	* components: initialization is bound to the parent script; use _self for dynamic handlers and such
	* Scripts are reloaded (recreated) upon zoning, dying, etc. -- beware of this for outside sources that reference scripts

====== Character Component
	
	* Initialized on character (depends on npc components)
	* Uses serialize/restore (server db, client script reloads), and netSerialize/netRestore for receiving state from server
	* Components are loaded once per character. When the character is reloaded, a new component is created from it
	* The component file is only loaded once, so cannot use SCRIPTINJECT (otherwise we hold onto stale vars and prolong their lifetime)
	* Be careful with serializing/restoring extra information on client, since if the character dies we netRestore and lose all local data
	* Make sure to unload

====== Functions

	reference: https://rainsoft.io/when-not-to-use-arrow-functions-in-javascript/
	never ever use `new Function()`: Fixed long wait time for node-inspector (https://github.com/nodejs/node/issues/7853)

	* function(){}  creates its own context. NOTE: this can be an issue with vars
		function Tacos(){
			this.cheesy = true;

			var CookThatTaco = function(){
				console.log("cheesy? " + this.cheesy); // cheesy? undefined
			};

			this.MakeATaco = function(){
				CookThatTaco(); // CookThatTaco is being called with no context, so its context is global
			};
		};

		var tacos = new Tacos();
		tacos.MakeATaco();

	* () => {}  uses context of the places its been defined. NOTE: this can be an issue with objects:
		var Tacos = {
			cheesy: true,
			MakeATaco: () => { console.log("cheesy? " + this.cheesy); } // cheesy? undefined
		}
		Tacos.MakeATaco(); // since MakeATaco is defined inside of the object, the context is window (undefined?) at the time

	* () => {}  is also bad with defining an object:
		var Tacos = () => { this.cheesy = true; }
		var tacos = new Tacos(); // Error: Tacos is not a constructor


	1) Defining a function/object:  use function
	2) function in an object literal: use function
		var Tacos = {
			MakeATaco: function(){}
		}
	3) method in an object: use function
		var Tacos = function(){
			this.MakeATaco = function(){}
		}
	4) var in an object: use arrow
		var Tacos = function(){
			var MakeATaco = () => {}
		}
	5) callback function: use arrow   (unless explicitly binding to something)
		player.hook('EVT_DIED').after(() => {})
	6) global function: use arrow
	7) callback within function literal: use arrow
		var Tacos = {
			MakeATaco: function(){
				user.hook('EVT_CANCEL_ORDER', () => {
					this.cancelOrder();
				});
			}
		}
	8) function within object within class: use arrow
		var Taco = function(){
		   this.toppings = { cheese: true, beef: true }
		   this.manage = {
			  printToppings: () => { console.log(this.toppings); }
		   }
		}
	9) function within function within object within class: use function
		var Taco = function(){
			const _Taco = this;
			this.manage = {

				// NOTE: initialize is called from another context
				initialize() {

					var giveCheese = function() { this.cheese++; };

					_Taco.giveCheese();
				}
			}
		}




	Arrow functions don't have arguments: https://jsfiddle.net/5daundpr/

	const Taco = function(initialToppings, cookingTime){

		this.setToppings = function(){};
		
		this.MakeATaco = () => {
			this.setToppings(arguments); // arguments: [initialToppings, cookingTime]  
		}
	}

};

====== Declaration

	reference: http://stackoverflow.com/questions/762011/let-keyword-vs-var-keyword

	* var: scoped to the nearest function block
	* let: scoped to the nearest enclosing block

	var vs. let: use let
	let vs const: use const


MAP EDITING
==========

==== NPCs

	* add spritesheet in tools editor to automatically update the avatars.png image
	* create a tilesheet called 'npcs' it must be called npcs otherwise it will be parsed as a tilesheet
	* if possible, prefer to set static npcs as sprites

==== Sprites

	* Sprites will be drawn out as 16x16; to get larger objects you need to specify the sheets as smaller tiles and draw each sprite as multiple tiles




BLENDER
==========

==== Modelling

    * Image as background: https://blender.stackexchange.com/questions/118/how-do-i-set-a-background-image-while-i-am-editing
	* Be sure to line up images so that it can mirror well
	* Add a plane at a good starting point (center of face); center the plane along the axis, edge cut (ctrl+r) along that axis and delete the other sides face, then add a mirror modifier (test that the plane was perfectly centered by trying to move the center vert)
	* Enable clipping on the mirror modifier (verts going passed the axis will snap to the axis)
	*

==== Contour Lines (edge highlighting)

	* https://www.youtube.com/watch?v=s13yr-kN_CI


EXTERNAL ASSETS
=================

==== Unity

    * .unitypackage is just a .tar.gz
    * Each folder contains 1 or 0 assets; each asset's true name is in the contents of pathname (including its original path). I suspect the folders without an asset (but still contain a pathname) are just folders

==== Blender

    * Multiple animations: if from Unity then its probably multiple .fbx files. Just import each animation to a separate layer
    * Lighting: Add a sun, and hemisphere light surrounding mesh on every angle (XYZ|+-1); can move to each layer for multiple layer/anims: m + shift click each layer
    * Shadeless: Mesh -> Material -> Shading -> [X] Shadeless;  this makes the mesh insensitive to any lighting
    * Dependencies: File -> External Data -> Find/Report Missing Files
    * Rendering: blender/cycles may depend on how it was already setup
    * Edge rendering: Render -> Post Processing -> Edge / Threshold 10
    * Transparent Background: Render -> Shading -> Alpha -> Transparent
